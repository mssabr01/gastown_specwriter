# TLA+ / PlusCal Specification Writing Skill

## Purpose
Read system documentation, requirements, or design docs and produce correct TLA+ specifications written in PlusCal algorithmic language.

## Workflow

1. **Read the input documentation** — Identify concurrency, state machines, invariants, liveness properties, and failure modes.
2. **Identify the modeling scope** — Determine what to model (processes, shared state, message channels) and what to abstract away.
3. **Write the PlusCal spec** — Follow the structure and rules below.
4. **Add TLA+ properties** — Define invariants and temporal properties after the PlusCal block.
5. **Output a `.tla` file** — Ready to run with the TLC model checker.

## PlusCal Spec Structure

Every spec MUST follow this skeleton:

```tla
--------------------------- MODULE ModuleName ---------------------------
EXTENDS Integers, Sequences, FiniteSets, TLC

CONSTANTS
    \* Declare constants here (e.g., NumProcesses, MaxVal)

VARIABLES
    \* Only declare variables NOT managed inside PlusCal if needed outside

(* --algorithm AlgorithmName

variables
    \* Shared global variables with initial values
    x = 0,
    queue = <<>>;

define
    \* Invariants and operators accessible inside PlusCal
    TypeOK ==
        /\ x \in Int
    SafetyProperty ==
        \* Your invariant here
        TRUE
end define;

\* Macros (optional — inline, no labels, no `await`/`while`)
macro send(msg, ch) begin
    ch := Append(ch, msg);
end macro;

\* Procedures (optional — can have labels)
procedure MyProcedure(arg)
variables local = 0;
begin
    ProcStep:
        local := arg + 1;
        return;
end procedure;

\* Processes
fair process Worker \in 1..NumProcesses
variables localVar = 0;
begin
    Start:
        \* process body
        skip;
    Loop:
        while TRUE do
            Step1:
                \* atomic step
                skip;
            Step2:
                skip;
        end while;
end process;

end algorithm; *)

\* BEGIN TRANSLATION — generated by TLC, leave blank
\* END TRANSLATION

\* Temporal / liveness properties (checked in TLC config)
Liveness == <>(\* some condition *)
Fairness == WF_vars(\* action *)

==========================================================================
```

## Critical PlusCal Rules

Prioritize making reusable patterns that can be easily repurposed for other specs where it makes sense

### Labels (Atomicity Boundaries)
- Each label defines one **atomic step**. All code between two labels executes without interleaving.
- **A label is REQUIRED:**
  - At the start of every `process` body and `procedure` body
  - After every `while`, `if`, `either`, or `with` keyword (if followed by more statements that need atomicity control)
  - Before every `call`, `return`, `goto`
  - After every `call` statement
- **Labels are FORBIDDEN inside macros.**
- When in doubt, **add more labels** — over-splitting is safe (it explores more interleavings), under-splitting hides bugs.

### Variables & Types
- Initialize ALL variables. TLC needs finite initial states.
- Use model values or small finite sets for constants (e.g., `NumProcesses = 3`).
- Prefer `\in` for nondeterministic choice: `x \in {1, 2, 3}`.
- Sequences: `<<1, 2, 3>>`, access with `seq[i]` (1-indexed).
- Sets: `{1, 2, 3}`, use `\union`, `\intersect`, `\`, `\in`, `\subseteq`.
- Functions (maps): `[key \in KeySet |-> InitVal]`.
- Records: `[field1 |-> val1, field2 |-> val2]`.

### Concurrency Constructs
- `either ... or ... or ... end either;` — nondeterministic choice
- `with x \in S do ... end with;` — nondeterministic selection from set
- `await condition;` — block until condition is true (use for synchronization)
- `skip;` — no-op placeholder

### Fairness
- `fair process` — weak fairness (WF): if a step is continuously enabled, it eventually executes.
- `fair+ process` — strong fairness (SF): if a step is repeatedly enabled, it eventually executes.
- Default to `fair process` unless modeling starvation.

### Common Modeling Patterns

**Mutex / Lock:**
```
variables lock = FALSE;
fair process P \in 1..N
begin
    Acquire:
        await lock = FALSE;
        lock := TRUE;
    CriticalSection:
        \* work
        skip;
    Release:
        lock := FALSE;
end process;
```
⚠️ The above is WRONG for real mutual exclusion (acquire is not atomic with the check). Use a correct pattern:
```
variables turn = 0, flag = [i \in 1..N |-> FALSE];
```
Or use `await` + assignment in a single label if modeling abstract locks.

**Message Passing (Channel):**
```
variables chan = <<>>;

macro send(msg) begin
    chan := Append(chan, msg);
end macro;

macro recv(var) begin
    await Len(chan) > 0;
    var := Head(chan);
    chan := Tail(chan);
end macro;
```

**Nondeterministic Failure:**
```
either
    \* succeed
    result := "ok";
or
    \* crash
    result := "fail";
end either;
```

## Writing Properties

### Invariants (Safety)
Place in `define` block. Checked at every reachable state.
```
define
    MutualExclusion == \A i, j \in 1..N : (i /= j) => ~(inCS[i] /\ inCS[j])
    NoOverflow == Len(queue) <= MaxLen
    TypeOK == x \in 0..10 /\ y \in BOOLEAN
end define;
```

### Temporal Properties (Liveness)
Place AFTER the translation block. Checked over behaviors.
```
\* Every request eventually gets a response
EventualResponse == \A i \in 1..N : [](request[i] => <>response[i])

\* The system eventually terminates
Termination == <>(pc = [p \in ProcSet |-> "Done"])
```

### Symmetry Sets
For model checking performance, declare symmetry sets in the TLC config when processes are interchangeable:
```
SYMMETRY Perms
```
Define `Perms == Permutations(1..N)` in the module.

## Extracting Specs from Documentation

When reading a design doc, requirements, or architecture description:

| Doc describes... | Model as... |
|---|---|
| Service / actor / thread | `process` |
| API call / RPC | `send` + `recv` on a channel variable |
| Database write | Shared variable assignment |
| Retry logic | `while` loop with `either` success/failure |
| Timeout | Nondeterministic `either` (succeed or timeout) |
| Queue / buffer | `Sequence` variable |
| Cache | Function `[key \in Keys |-> ...]` |
| Distributed consensus | Multiple processes + message channels |
| "At most once" / "exactly once" | Safety invariant on a counter |
| "Eventually consistent" | Liveness property with `<>` |
| "No deadlock" | Built-in TLC deadlock check (enabled by default) |

## Output Checklist

Before delivering the `.tla` file, verify:

- [ ] Module name matches filename
- [ ] All variables initialized
- [ ] All constants declared (with suggested model values in comments)
- [ ] Every process body starts with a label
- [ ] No labels inside macros
- [ ] `await` is not used in macros (use in process labels instead)
- [ ] At least one invariant (`TypeOK` at minimum)
- [ ] Safety properties in `define` block
- [ ] Liveness properties after translation block (if applicable)
- [ ] Constants use small finite domains (model-checkable)
- [ ] File ends with `=====...` line

## Common Mistakes to Avoid

1. **Forgetting labels after `while`** — causes translation errors.
2. **Putting `await` in macros** — forbidden; move to labeled steps in processes.
3. **Unbounded variables** — TLC cannot check infinite state spaces. Always bound.
4. **Modeling too much** — abstract away irrelevant detail. Focus on the concurrency/distributed aspects.
5. **Single-label processes** — if an entire process body is one label, there's no interleaving to check. Split into meaningful atomic steps.
6. **Using `=` instead of `==`** for definitions — `=` is assignment, `==` is definition.
7. **Forgetting `end algorithm;`** — the PlusCal block must close properly.
